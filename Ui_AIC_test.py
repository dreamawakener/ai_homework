# Form implementation generated from reading ui file 'd:\Code\Python\pyQT\AcademicIntegrityChecker.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
# 在AcademicIntegrityChecker类中，需要传入模型名称
import re
import sys
import time
import json
from typing import Dict, List, Optional, Tuple, Union
from camel.agents import ChatAgent
from camel.messages import BaseMessage
from camel.models import ModelFactory
from camel.types import ModelPlatformType, ModelType
from PyQt6.QtGui import QTextCursor, QTextCharFormat, QColor
import openai
# 导入配置管理
from config import get_api_key, get_base_url, get_model_name

my_api_key = get_api_key()
my_base_url = get_base_url()
my_model_name = get_model_name()

class AcademicIntegrityChecker:
    """学术诚信检查器，用于识别违反学术诚信的请求"""
    
    def __init__(self,ptr):
        # 违反学术诚信的关键词和短语
        self.aic_ptr = ptr
        self.violation_patterns = [
            # 直接生成全文相关
            r'(帮我|替我|给我)?(写|生成|创建)(一篇|完整的?|全部的?)(论文|研究报告|学术论文)',
            r'(代写|代做|帮写)(论文|作业|研究报告)',
            r'(完整的?|整篇|全文)(论文|研究报告).*生成',
            r'从头.*写.*论文',
            r'写.*完整.*论文',
            
            # 抄袭相关
            r'(复制|抄袭|照搬).*论文',
            r'(改写|重写).*别人.*论文',
            r'(洗稿|换句话说).*论文',
            
            # 学术欺诈相关
            r'(伪造|编造|虚构)(数据|实验结果|引用)',
            r'(假的|虚假的)(实验|数据|结果)',
            r'(编造|杜撰)(参考文献|引用|实验)',
            
            # 直接要求答案
            r'(直接给|告诉我)(答案|结论|结果)',
            r'帮我.*解决.*所有.*问题',
        ]
        
        # 允许的学术协助请求
        self.allowed_patterns = [
            r'(润色|优化|改进|修改)(语言|表达|句子)',
            r'(扩写|扩展|丰富)(段落|章节|内容)',
            r'(总结|概括|提炼)(内容|要点|观点)',
            r'(检查|修正)(语法|拼写|格式)',
            r'(翻译|英文润色)',
            r'(学术写作|写作技巧|论文结构).*建议',
            r'(引用格式|参考文献格式)',
        ]
    
    def check_request(self, request: str) -> Tuple[bool, Optional[str]]:
        """
        使用正则表达式检查请求是否违反学术诚信
        
        Args:
            request: 用户请求内容
            
        Returns:
            Tuple[bool, Optional[str]]: (是否违反, 违反原因)
        """
        request_lower = request.lower()
        
        # 检查是否匹配违反学术诚信的模式
        for pattern in self.violation_patterns:
            if re.search(pattern, request_lower):
                return True, "检测到可能违反学术诚信的请求"
        
        # 检查请求长度和内容复杂度（防止要求生成大量内容）
        if len(request) > 1000 and any(keyword in request_lower for keyword in 
                                    ['写', '生成', '创建', '完成', '帮我做']):
            return True, "请求内容过于复杂，可能涉及代写"
        
        return False, None
    
    def ai_check_request(self, request: str, client, model_name: str) -> Tuple[bool, Optional[str]]:
        """
        使用大模型分析请求是否违反学术诚信
        
        Args:
            request: 用户请求内容
            client: OpenAI兼容客户端
            model_name: 模型名称
            
        Returns:
            Tuple[bool, Optional[str]]: (是否违反, 违反原因)
        """
        system_prompt = """你是一个学术诚信检查专家。请分析用户的请求是否违反学术诚信原则。

学术诚信违规包括但不限于：
1. 代写完整论文、作业或研究报告
2. 生成大量原创学术内容（超过几个段落）
3. 抄袭、洗稿或直接复制他人作品
4. 编造实验数据、引用或研究结果
5. 要求直接提供标准答案而非指导

合法的学术协助包括：
1. 语言润色和表达优化
2. 基于已有内容的扩写建议
3. 内容总结和要点提炼
4. 学术写作技巧指导
5. 格式规范建议

请用JSON格式回复：
{
    "is_violation": true/false,
    "reason": "具体原因",
    "confidence": 0.0-1.0
}"""
        
        try:
            response = client.chat.completions.create(
                model=model_name,  # 使用传入的模型名称
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"请分析这个请求：{request}"}
                ],
                temperature=0.1,
                max_tokens=500
            )
            
            result_text = response.choices[0].message.content.strip()
            
            # 简单解析JSON结果
            if '"is_violation": true' in result_text:
                # 提取原因
                reason_start = result_text.find('"reason": "') + 11
                reason_end = result_text.find('"', reason_start)
                reason = result_text[reason_start:reason_end] if reason_end > reason_start else "AI检测到违规内容"
                return True, reason
            else:
                return False, None
                
        except Exception as e:
            # AI检查失败时，只依赖正则表达式结果
            self.aic_ptr.textEdit_2.append(f"AI检查失败: {e}")
            return False, None
    
    def is_allowed_assistance(self, request: str) -> bool:
        """检查是否为允许的学术协助请求"""
        request_lower = request.lower()
        
        for pattern in self.allowed_patterns:
            if re.search(pattern, request_lower):
                return True
        
        return False


class AcademicWritingAgent:
    """专业论文写作助手Agent，负责具体的学术写作任务"""
    
    def __init__(self, client, model_name: str,ptr):
        """
        初始化论文写作Agent
        
        Args:
            client: OpenAI兼容客户端
            model_name: 模型名称
        """
        self.client = client
        self.model = model_name
        self.conversation_history = []
        self.aic_ptr = ptr
        
        # 专业的论文写作系统提示
        self.system_prompt = """你是一位经验丰富的学术论文写作专家，拥有深厚的学术研究背景和丰富的论文指导经验。

你的核心能力包括：
🎯 **语言润色与优化**
- 提升学术表达的准确性和专业性
- 改进句式结构，增强文章流畅度
- 优化用词选择，符合学术写作规范

📝 **内容扩展与丰富**
- 基于用户提供的要点进行合理扩写
- 补充相关理论背景和研究现状
- 添加逻辑连接，增强论证力度

📋 **结构优化与完善**
- 提供论文章节结构建议
- 优化段落组织和逻辑顺序
- 改善引言、正文、结论的衔接

🔍 **内容分析与总结**
- 提炼文献的核心观点和贡献
- 总结研究方法和主要发现
- 概括论文的创新点和价值

📚 **格式规范与引用**
- 提供APA、MLA、Chicago等引用格式指导
- 规范图表、公式的学术格式
- 完善参考文献列表

⚠️  **重要原则**：
- 严格遵守学术诚信，绝不代写完整论文
- 仅对用户已有内容进行改进和优化
- 提供建设性指导而非直接替代用户思考
- 保持客观中立的学术态度

如果用户给出的内容为中文，则使用中文答复，指解答正文使用中文，解释使用中文；
如果为英文，则使用英文答复，指解答正文使用英文，用中文进行讲解。
请根据用户的具体需求，提供专业、详细、实用的学术写作指导。"""
        
        self.conversation_history.append({"role": "system", "content": self.system_prompt})
    
    def analyze_task_type(self, request: str) -> Dict[str, Union[str, List[str]]]:
        """
        分析用户请求的任务类型
        
        Args:
            request: 用户请求
            
        Returns:
            Dict: 包含任务类型和建议的字典
        """
        task_patterns = {
            "language_polish": ["润色", "优化", "改进", "修改", "表达"],
            "content_expansion": ["扩写", "扩展", "丰富", "详细", "补充"],
            "summarization": ["总结", "概括", "提炼", "摘要"],
            "structure_advice": ["结构", "章节", "组织", "框架", "大纲"],
            "grammar_check": ["语法", "拼写", "格式", "错误"],
            "citation_format": ["引用", "参考文献", "格式", "标注"],
            "translation": ["翻译", "英文", "中文"],
            "writing_guidance": ["写作", "技巧", "方法", "建议", "指导"]
        }
        
        detected_types = []
        request_lower = request.lower()
        
        for task_type, keywords in task_patterns.items():
            if any(keyword in request_lower for keyword in keywords):
                detected_types.append(task_type)
        
        # 如果没有检测到明确类型，归类为一般写作指导
        if not detected_types:
            detected_types = ["writing_guidance"]
        
        return {
            "task_types": detected_types,
            "primary_type": detected_types[0] if detected_types else "writing_guidance",
            "suggestions": self._get_task_suggestions(detected_types[0] if detected_types else "writing_guidance")
        }
    
    def _get_task_suggestions(self, task_type: str) -> List[str]:
        """根据任务类型提供建议"""
        suggestions_map = {
            "language_polish": [
                "请提供需要润色的具体文本段落",
                "说明希望改进的方向（流畅度、专业性等）",
                "标注您认为有问题的句子或表达"
            ],
            "content_expansion": [
                "提供需要扩写的核心要点或段落",
                "说明扩写的目标长度和深度",
                "明确扩写的重点方向（理论、实例、分析等）"
            ],
            "summarization": [
                "提供需要总结的完整文本",
                "说明总结的目标长度",
                "指明需要重点关注的方面"
            ],
            "structure_advice": [
                "描述论文的主题和研究问题",
                "说明论文类型（实证研究、文献综述等）",
                "提供现有的结构框架或想法"
            ],
            "grammar_check": [
                "提供需要检查的具体文本",
                "说明文本的学科背景",
                "标注您不确定的语法点"
            ],
            "citation_format": [
                "说明需要的引用格式（APA、MLA等）",
                "提供需要格式化的引用信息",
                "明确引用类型（期刊、书籍、网页等）"
            ],
            "translation": [
                "提供需要翻译的原文",
                "说明翻译的学科领域",
                "标注专业术语和关键概念"
            ],
            "writing_guidance": [
                "描述具体的写作困难或问题",
                "说明论文的主题和研究阶段",
                "提供现有的写作内容或想法"
            ]
        }
        
        return suggestions_map.get(task_type, ["请详细描述您的具体需求"])
    
    def process_request(self, request: str, typing_delay: float = 0.001) -> str:
        """
        处理学术写作请求
        
        Args:
            request: 用户请求
            typing_delay: 打字机效果延迟
            
        Returns:
            str: 处理结果
        """
        # 分析任务类型
        task_analysis = self.analyze_task_type(request)
        
        # 构建专业的响应提示
        enhanced_request = f"""
任务分析：
- 主要任务类型：{task_analysis['primary_type']}
- 检测到的任务类型：{', '.join(task_analysis['task_types'])}

用户请求：{request}

请作为专业的学术写作专家，根据任务类型提供详细、实用的指导和帮助。
如果用户提供了具体的文本内容，请对其进行专业的分析和改进建议。
"""
        
        # 添加到对话历史
        self.conversation_history.append({"role": "user", "content": enhanced_request})
        
        try:
            # 创建流式请求
            stream = self.client.chat.completions.create(
                model=self.model,
                messages=self.conversation_history,
                temperature=0.7,  # 适中的温度，保持专业性的同时允许一定创造性
                max_tokens=4096,
                stream=True
            )
            
            full_response = ""
            self.aic_ptr.append_text("📝 论文写作助手: ", color="black", newline=False)
            
            # 逐块处理流式响应
            for chunk in stream:
                if chunk.choices[0].delta.content is not None:
                    content = chunk.choices[0].delta.content
                    full_response += content
                    
                    cursor = self.aic_ptr.textEdit_2.textCursor()
                    char_format = QTextCharFormat()
                    char_format.setForeground(QColor("black"))
                    cursor.setCharFormat(char_format)
                    cursor.movePosition(QtGui.QTextCursor.MoveOperation.End)
                    
                    for char in content:
                        # 插入单个字符
                        cursor.insertText(char)
                        
                        # 确保UI更新
                        QtCore.QCoreApplication.processEvents()
                        
                        # 控制输出速度
                        time.sleep(typing_delay)
                    
                    # 确保光标可见
                    self.spws_ptr.textEdit.setTextCursor(cursor)
                    self.spws_ptr.textEdit.ensureCursorVisible()
                    
                    # # 打字机效果输出
                    # for char in content:
                    #     sys.stdout.write(char)
                    #     sys.stdout.flush()
                    #     time.sleep(typing_delay)
            
            self.aic_ptr.textEdit_2.append('\n')
            
            # 将助手响应添加到历史
            self.conversation_history.append({"role": "assistant", "content": full_response})
            
            return full_response
            
        except Exception as e:
            error_msg = f"处理请求时发生错误：{str(e)}"
            print(error_msg)
            return error_msg
    
    def get_writing_tips(self, topic: str = "general") -> str:
        """提供学术写作技巧"""
        tips_request = f"请为'{topic}'主题提供专业的学术写作技巧和建议"
        return self.process_request(tips_request)
    
    def reset_conversation(self):
        """重置对话历史，保留系统提示"""
        self.conversation_history = [self.conversation_history[0]]  # 只保留系统提示


class AcademicWritingAssistant:
    """增强版学术论文写作助手，整合学术诚信检查和专业写作Agent"""
    
    def __init__(self, api_key: str = "", base_url: str = "https://api.siliconflow.cn/v1", 
                model_name: str = "Pro/deepseek-ai/DeepSeek-V3",ptr=None):
        """
        初始化写作助手
        
        Args:
            api_key: API密钥
            base_url: API基础URL
            model_name: 模型名称
        """
        self.aic_ptr = ptr
        self.integrity_checker = AcademicIntegrityChecker(ptr=self.aic_ptr)
        # 初始化OpenAI兼容客户端
        self.client = openai.OpenAI(
            api_key=api_key,
            base_url=base_url
        )
        
        # 设置模型名称
        self.model = model_name
        
        # 初始化专业写作Agent
        self.writing_agent = AcademicWritingAgent(self.client, self.model,ptr=self.aic_ptr)
        
        # 统计信息
        self.stats = {
            "total_requests": 0,
            "approved_requests": 0,
            "rejected_requests": 0,
            "task_types": {}
        }
    
    def process_request(self, user_input: str, typing_delay: float = 0.001, 
                    show_progress: bool = True) -> str:
        """
        处理用户请求（完整流程：学术诚信检查 + 专业写作协助）
        
        Args:
            user_input: 用户输入的请求
            typing_delay: 打字机效果延迟
            show_progress: 是否显示处理进度
            
        Returns:
            str: 完整的响应内容
        """
        self.stats["total_requests"] += 1
        
        if show_progress:
            self.aic_ptr.textEdit_2.append("🔍 正在进行学术诚信检查...")
        
        # 双重学术诚信检查
        # 1. 正则表达式检查
        is_violation_regex, reason_regex = self.integrity_checker.check_request(user_input)
        
        # 2. AI智能检查
        is_violation_ai, reason_ai = self.integrity_checker.ai_check_request(
            user_input, self.client, self.model
        )
        
        # 如果任一检查发现违规，则拒绝服务
        if is_violation_regex or is_violation_ai:
            self.stats["rejected_requests"] += 1
            violation_reason = reason_ai if reason_ai else reason_regex
            rejection_msg = self._generate_rejection_message(violation_reason)
            
            if show_progress:
                self.aic_ptr.textEdit_2.append("❌ 学术诚信检查未通过")
            
            # 流式输出拒绝消息
            self.aic_ptr.append_text("🚫 学术诚信检查器:: ", color="black", newline=False)
            
            for char in rejection_msg:
                sys.stdout.write(char)
                sys.stdout.flush()
                time.sleep(typing_delay)
            self.aic_ptr.textEdit_2.append('\n')
            
            return rejection_msg
        
        # 检查是否为允许的协助请求
        if not self.integrity_checker.is_allowed_assistance(user_input):
            if self._is_potentially_problematic(user_input):
                self.stats["rejected_requests"] += 1
                rejection_msg = self._generate_rejection_message("请求可能违反学术诚信原则")
                
                if show_progress:
                    self.aic_ptr.textEdit_2.append("❌ 请求可能存在问题")
                
                # 流式输出拒绝消息
                self.aic_ptr.textEdit_2.append("🚫 学术诚信检查器: ", end="", flush=True)
                
                for char in rejection_msg:
                    sys.stdout.write(char)
                    sys.stdout.flush()
                    time.sleep(typing_delay)
                self.aic_ptr.textEdit_2.append('\n')
                
                return rejection_msg
        
        if show_progress:
            self.aic_ptr.textEdit_2.append("✅ 学术诚信检查通过")
            self.aic_ptr.textEdit_2.append("🤖 启动专业论文写作助手...")
        
        # 通过检查，交给专业写作Agent处理
        self.stats["approved_requests"] += 1
        
        # 分析任务类型并更新统计
        task_analysis = self.writing_agent.analyze_task_type(user_input)
        primary_type = task_analysis["primary_type"]
        self.stats["task_types"][primary_type] = self.stats["task_types"].get(primary_type, 0) + 1
        
        # 处理请求
        response = self.writing_agent.process_request(user_input, typing_delay)
        
        return response
    
    def _is_potentially_problematic(self, request: str) -> bool:
        """检查请求是否存在潜在问题"""
        problematic_indicators = [
            len(request.split()) > 200,  # 请求过长
            '帮我完成' in request and '论文' in request,
            '全部' in request and ('写' in request or '做' in request),
            '代替我' in request,
        ]
        
        return any(problematic_indicators)
    
    def _generate_rejection_message(self, reason: str) -> str:
        """生成拒绝服务的消息"""
        return f"""很抱歉，我无法处理您的请求。

🚫 违反学术诚信原则

原因：{reason}

✅ 我可以为您提供以下类型的专业学术写作协助：

📝 **语言润色与优化**
• 改进学术表达的准确性和专业性
• 优化句式结构，增强文章流畅度
• 提升用词选择，符合学术写作规范

📋 **内容扩展与丰富**
• 基于您提供的要点进行合理扩写
• 补充相关理论背景和研究现状
• 添加逻辑连接，增强论证力度

🔍 **内容分析与总结**
• 提炼文献的核心观点和贡献
• 总结研究方法和主要发现
• 概括论文的创新点和价值

📚 **格式规范与引用**
• 提供各种引用格式指导
• 规范图表、公式的学术格式
• 完善参考文献列表

💡 **使用建议**：请提供您已经撰写的具体内容或明确的改进需求，我将为您提供专业的学术写作指导。

学术诚信是研究工作的基石，让我们一起维护良好的学术环境！"""
    
    def get_stats(self) -> Dict:
        """获取使用统计信息"""
        return self.stats.copy()
    
    def reset_agent(self):
        """重置写作Agent的对话历史"""
        self.writing_agent.reset_conversation()
    
    def get_writing_tips(self, topic: str = "general") -> str:
        """获取写作技巧"""
        return self.writing_agent.get_writing_tips(topic)



class AIC(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.label = QtWidgets.QLabel(parent=self.centralwidget)
        self.label.setGeometry(QtCore.QRect(370, 30, 181, 51))
        self.label.setObjectName("label")
        self.listWidget = QtWidgets.QListWidget(parent=self.centralwidget)
        self.listWidget.setGeometry(QtCore.QRect(40, 90, 201, 61))
        self.listWidget.setObjectName("listWidget")
        item = QtWidgets.QListWidgetItem()
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        self.listWidget.addItem(item)
        self.textEdit = QtWidgets.QTextEdit(parent=self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(140, 160, 641, 71))
        self.textEdit.setObjectName("textEdit")
        self.textEdit_2 = QtWidgets.QTextEdit(parent=self.centralwidget)
        self.textEdit_2.setGeometry(QtCore.QRect(140, 240, 641, 291))
        self.textEdit_2.setObjectName("textEdit_2")
        self.label_2 = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(50, 180, 54, 16))
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(50, 370, 54, 16))
        self.label_3.setObjectName("label_3")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.label.setText(_translate("MainWindow", "Academic_Integrity_Checker"))
        __sortingEnabled = self.listWidget.isSortingEnabled()
        self.listWidget.setSortingEnabled(False)
        item = self.listWidget.item(0)
        item.setText(_translate("MainWindow", "功能1. 交互式对话模式"))
        item = self.listWidget.item(1)
        item.setText(_translate("MainWindow", "功能2. 自动演示模式"))
        item = self.listWidget.item(2)
        item.setText(_translate("MainWindow", "功能3.功能展示模式"))
        self.listWidget.setSortingEnabled(__sortingEnabled)
        self.label_2.setText(_translate("MainWindow", "输入内容"))
        self.label_3.setText(_translate("MainWindow", "输出内容"))
        self.listWidget.itemClicked.connect(self.on_item_clicked)
        
    def on_item_clicked(self, item):
        text = item.text()
        
        if text == "功能1. 交互式对话模式":
            self.main()
        elif text == "功能2. 自动演示模式":
            self.demo_test()
        elif text == "功能3.功能展示模式":
            self.interactive_demo()
        else:
            self.aic_ptr.textEdit_2.append("无效选择，启动默认交互模式...")
            self.main()

    # 使用示例
    def main(self):
        """主函数示例"""
        # 配置您的API信息
        my_api_key = "sk-qullgfjnwatfbztwedpwajnagikznfbimlotgxhlloyrbkax"  # 请填入您的API密钥
        my_base_url = "https://api.siliconflow.cn/v1"
        my_model_name = "Pro/deepseek-ai/DeepSeek-V3"
        
        # 初始化增强版助手
        assistant = AcademicWritingAssistant(
            api_key=my_api_key,
            base_url=my_base_url,
            model_name=my_model_name,
            ptr=self
        )
        
        self.textEdit_2.append("=== 增强版学术论文写作助手 ===")
        self.textEdit_2.append(f"🤖 使用模型: {my_model_name}")
        self.textEdit_2.append(f"🌐 服务地址: {my_base_url}")
        self.textEdit_2.append("✨ 功能特色：学术诚信检查 + 专业论文写作Agent")
        self.textEdit_2.append("📋 支持：语言润色、内容扩写、结构建议、格式规范等")
        self.textEdit_2.append("\n输入 'quit' 退出程序")
        self.textEdit_2.append("输入 'stats' 查看使用统计")
        self.textEdit_2.append("输入 'tips [主题]' 获取写作技巧")
        self.textEdit_2.append("输入 'reset' 重置对话历史\n")
        
        while True:
            try:
                user_input = self.textEdit().toPlainText().strip()
                
                if user_input.lower() in ['quit', 'exit', '退出']:
                    # 显示最终统计
                    stats = assistant.get_stats()
                    self.textEdit_2.append(f"\n📊 使用统计:")
                    self.textEdit_2.append(f"总请求数: {stats['total_requests']}")
                    self.textEdit_2.append(f"通过请求: {stats['approved_requests']}")
                    self.textEdit_2.append(f"拒绝请求: {stats['rejected_requests']}")
                    if stats['task_types']:
                        self.textEdit_2.append("任务类型分布:")
                        for task_type, count in stats['task_types'].items():
                            self.textEdit_2.append(f"  {task_type}: {count}")
                    self.textEdit_2.append("👋 再见！")
                    break
                
                if user_input.lower() == 'stats':
                    stats = assistant.get_stats()
                    self.textEdit_2.append(f"\n📊 当前使用统计:")
                    self.textEdit_2.append(f"总请求数: {stats['total_requests']}")
                    self.textEdit_2.append(f"通过请求: {stats['approved_requests']}")
                    self.textEdit_2.append(f"拒绝请求: {stats['rejected_requests']}")
                    if stats['task_types']:
                        self.textEdit_2.append("任务类型分布:")
                        for task_type, count in stats['task_types'].items():
                            self.textEdit_2.append(f"  {task_type}: {count}")
                    continue
                
                if user_input.lower().startswith('tips'):
                    topic = user_input[4:].strip() if len(user_input) > 4 else "general"
                    self.textEdit_2.append(f"\n📚 获取'{topic}'相关的写作技巧...")
                    assistant.get_writing_tips(topic)
                    self.textEdit_2.append("\n" + "="*50 + "\n")
                    continue
                
                if user_input.lower() == 'reset':
                    assistant.reset_agent()
                    self.textEdit_2.append("🔄 对话历史已重置")
                    continue
                
                if not user_input.strip():
                    continue
                
                self.textEdit_2.append('\n')  # 换行
                
                # 处理请求（包含学术诚信检查和专业写作协助）
                response = assistant.process_request(
                    user_input, 
                    typing_delay=0.01,  # 可调整打字速度
                    show_progress=True
                )
                
                self.textEdit_2.append("\n" + "="*50 + "\n")
                
            except KeyboardInterrupt:
                self.textEdit_2.append("\n👋 程序已退出")
                break
            except Exception as e:
                self.textEdit_2.append(f"发生错误: {e}")


    def demo_test(self):
        """演示测试函数"""
        # 配置您的API信息
        my_api_key = "sk-qullgfjnwatfbztwedpwajnagikznfbimlotgxhlloyrbkax"  # 请填入您的API密钥
        my_base_url = "https://api.siliconflow.cn/v1"
        my_model_name = "Pro/deepseek-ai/DeepSeek-V3"
        
        # 初始化助手
        assistant = AcademicWritingAssistant(
            api_key=my_api_key,
            base_url=my_base_url,
            model_name=my_model_name,
            ptr=self
        )
        
        # 测试请求
        test_requests = [
            "帮我写一篇关于人工智能的完整论文",  # 违反学术诚信
            """请帮我润色这段话：人工智能技术发展迅速，在各个领域都有应用。特别是在医疗、金融和教育等行业，AI技术正在改变传统的工作方式。""",  # 合法请求
            "请帮我扩写这个观点：深度学习在图像识别中具有显著优势，主要体现在特征提取和模式识别能力上。",  # 合法请求
            "代写一篇5000字的研究报告",  # 违反学术诚信
            """请总结一下这段内容的要点：深度学习是机器学习的一个分支，它模拟人脑神经网络的结构和功能。通过多层神经网络，深度学习能够自动学习数据的特征表示，在图像识别、自然语言处理、语音识别等领域取得了突破性进展。"""  # 合法请求
        ]
        
        self.textEdit_2.append("=== 增强版学术论文写作助手演示 ===")
        self.textEdit_2.append(f"🤖 使用模型: {my_model_name}")
        self.textEdit_2.append(f"🌐 服务地址: {my_base_url}")
        self.textEdit_2.append("✨ 功能特色：学术诚信检查 + 专业论文写作Agent\n")
        
        for i, request in enumerate(test_requests, 1):
            self.textEdit_2.append(f"📝 测试 {i}: {request[:50]}{'...' if len(request) > 50 else ''}")
            self.textEdit_2.append("-" * 70)
            
            response = assistant.process_request(
                request,
                typing_delay=0.005,  # 演示时稍快一些
                show_progress=True
            )
            
            self.textEdit_2.append("\n" + "="*70 + "\n")
        
        # 显示最终统计
        self.textEdit_2.append("📊 演示完成，最终统计:")
        stats = assistant.get_stats()
        self.textEdit_2.append(f"总请求数: {stats['total_requests']}")
        self.textEdit_2.append(f"通过请求: {stats['approved_requests']}")
        self.textEdit_2.append(f"拒绝请求: {stats['rejected_requests']}")
        if stats['task_types']:
            self.textEdit_2.append("任务类型分布:")
            for task_type, count in stats['task_types'].items():
                self.textEdit_2.append(f"  {task_type}: {count}")


    def interactive_demo(self):
        """交互式演示，展示不同功能"""

        assistant = AcademicWritingAssistant(
            api_key=my_api_key,
            base_url=my_base_url,
            model_name=my_model_name,
            ptr=self
        )
        
        self.textEdit_2.append("=== 交互式功能演示 ===")
        self.textEdit_2.append("🎯 本演示将展示不同类型的学术写作协助功能\n")
        
        # 演示场景
        scenarios = [
            {
                "title": "语言润色",
                "description": "优化学术表达，提升文本质量",
                "example": "请帮我润色这段话：机器学习算法在数据分析方面有很好的效果，能够处理大量数据并找出规律。"
            },
            {
                "title": "内容扩写", 
                "description": "基于要点进行合理扩展",
                "example": "请帮我扩写这个观点：卷积神经网络在计算机视觉领域具有重要作用。"
            },
            {
                "title": "结构建议",
                "description": "提供论文结构和组织建议", 
                "example": "我正在写一篇关于自然语言处理的论文，请给我一些结构建议。"
            },
            {
                "title": "内容总结",
                "description": "提炼文本要点和核心观点",
                "example": "请总结这段文字的要点：Transformer模型是一种基于注意力机制的神经网络架构，它在自然语言处理任务中表现出色。该模型摒弃了传统的循环神经网络结构，完全依赖注意力机制来处理序列数据，从而实现了并行计算和更好的长距离依赖建模能力。"
            }
        ]
        
        for i, scenario in enumerate(scenarios, 1):
            self.textEdit_2.append(f"🎭 场景 {i}: {scenario['title']}")
            self.textEdit_2.append(f"📝 描述: {scenario['description']}")
            self.textEdit_2.append(f"💡 示例请求: {scenario['example']}")
            
            proceed = input("\n是否运行此演示? (y/n): ").lower().strip()
            if proceed == 'y':
                self.textEdit_2.append("\n" + "-"*50)
                assistant.process_request(
                    scenario['example'],
                    typing_delay=0.01,
                    show_progress=True
                )
                self.textEdit_2.append("-"*50 + "\n")
            
            if i < len(scenarios):
                input("按回车键继续下一个演示...")
                self.textEdit_2.append('\n')
        
        self.textEdit_2.append("🎉 所有演示完成！")
        
        # 显示统计信息
        stats = assistant.get_stats()
        self.textEdit_2.append(f"\n📊 演示统计:")
        self.textEdit_2.append(f"总请求数: {stats['total_requests']}")
        self.textEdit_2.append(f"通过请求: {stats['approved_requests']}")
        self.textEdit_2.append(f"拒绝请求: {stats['rejected_requests']}")

    def append_text(self, text, color="black", newline=True):
        """向 textEdit 添加文本（可选择颜色和是否换行）"""
        cursor = self.textEdit_2.textCursor()
        cursor.movePosition(QtGui.QTextCursor.MoveOperation.End)
        
        # 设置文本格式
        fmt = QtGui.QTextCharFormat()
        if color == "red":
            fmt.setForeground(QtGui.QColor("#FF0000"))  # 红色
        elif color == "green":
            fmt.setForeground(QtGui.QColor("#00FF00"))  # 绿色
        elif color == "yellow":
            fmt.setForeground(QtGui.QColor("#FFD700"))  # 黄色
        elif color == "blue":
            fmt.setForeground(QtGui.QColor("#0000FF"))  # 蓝色
        elif color == "magenta":
            fmt.setForeground(QtGui.QColor("#FF00FF"))  # 洋红
        elif color == "cyan":
            fmt.setForeground(QtGui.QColor("#00FFFF"))  # 青色
        else:
            fmt.setForeground(QtGui.QColor("#000000"))  # 默认黑色
        
        # 插入文本
        cursor.insertText(text, fmt)
        if newline:
            cursor.insertText("\n")
        
        self.textEdit.setTextCursor(cursor)
        self.textEdit.ensureCursorVisible()


