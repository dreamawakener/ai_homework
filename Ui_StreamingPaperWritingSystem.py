# Form implementation generated from reading ui file 'd:\Code\Python\pyQT\StreamingPaperWritingSystem.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
# Form implementation generated from reading ui file 'd:\Code\Python\pyQT\StreamingPaperWritingSystem.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import openai
import sys
import time
import requests
import xml.etree.ElementTree as ET
from urllib.parse import quote
import re
from datetime import datetime, timedelta
from typing import List, Dict
from camel.agents import ChatAgent
from camel.models import ModelFactory
from camel.types import ModelPlatformType
from camel.utils import print_text_animated
from colorama import Fore, init
from camel.societies import RolePlaying
from dotenv import load_dotenv
import os
import json
from bs4 import BeautifulSoup
from datetime import datetime
from urllib.parse import quote
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtGui import QTextCursor, QTextCharFormat, QColor

# åˆå§‹åŒ–colorama
init(autoreset=True)
# å¯¼å…¥é…ç½®ç®¡ç†
from config import get_api_key, get_base_url, get_model_name

my_api_key = get_api_key()
my_base_url = get_base_url()
my_model_name = get_model_name()


class ArxivCrawler:
    """ArXivè®ºæ–‡çˆ¬è™« - ä½¿ç”¨ç½‘é¡µæœç´¢"""

    def __init__(self,ptr):
        self.base_url = "https://arxiv.org/search/"
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }
        self.openai_client = openai.OpenAI(api_key=my_api_key, base_url=my_base_url)
        self.model_name = my_model_name
        self.spws_ptr = ptr  # ç”¨äºä¸SPWSäº¤äº’
    def translate_query(self, query: str) -> str:
        """å°†ä¸­æ–‡æŸ¥è¯¢è¯ç¿»è¯‘ä¸ºè‹±æ–‡"""
        try:
            # æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
            if any('\u4e00' <= char <= '\u9fff' for char in query):
                self.spws_ptr.append_colored_text(f"ğŸ” æ£€æµ‹åˆ°ä¸­æ–‡æŸ¥è¯¢è¯: {query}ï¼Œæ­£åœ¨ç¿»è¯‘...","yellow")
                # æ„å»ºç¿»è¯‘æç¤º
                prompt = f"è¯·å°†ä»¥ä¸‹ä¸­æ–‡æŸ¥è¯¢è¯ç¿»è¯‘ä¸ºè‹±æ–‡ï¼Œç”¨äºå­¦æœ¯æ–‡çŒ®æœç´¢ï¼š\n{query}"
                response = self.openai_client.chat.completions.create(
                    model=self.model_name,
                    messages=[
                        {"role": "system", "content": "ä½ æ˜¯ä¸€åä¸“ä¸šçš„å­¦æœ¯ç¿»è¯‘ä¸“å®¶ï¼Œéœ€å°†ä¸­æ–‡å‡†ç¡®è¯‘ä¸ºè‹±æ–‡å­¦æœ¯å…³é”®è¯"},
                        {"role": "user", "content": prompt}
                    ],
                    temperature=0.2,
                    max_tokens=100
                )
                # æå–ç¿»è¯‘ç»“æœï¼ˆå»é™¤å¯èƒ½çš„æ ‡ç‚¹å’Œå¤šä½™ç©ºæ ¼ï¼‰
                translation = response.choices[0].message.content.strip()
                # å¤„ç†å¯èƒ½çš„æ ‡ç‚¹ç¬¦å·ï¼ˆå¦‚ç»“å°¾çš„å¥å·ï¼‰
                if translation.endswith('.'):
                    translation = translation[:-1]
                self.spws_ptr.append_colored_text(f"âœ… ç¿»è¯‘å®Œæˆ: {translation}","green")
                return translation
            return query  # éä¸­æ–‡ç›´æ¥è¿”å›åŸè¯
        except Exception as e:
            self.spws_ptr.append_colored_text(f"âŒ ç¿»è¯‘å¤±è´¥: {e}ï¼Œä½¿ç”¨åŸè¯æœç´¢","red")
            return query
    def search_papers(self, query: str, max_results: int = 50) -> List[Dict]:
        """
        ä»ArXivæœç´¢ç›¸å…³è®ºæ–‡
        Args:
            query: æœç´¢å…³é”®è¯
            max_results: æœ€å¤§è¿”å›ç»“æœæ•°
        Returns:
            è®ºæ–‡ä¿¡æ¯åˆ—è¡¨
        """
        translated_query = self.translate_query(query)
        self.spws_ptr.append_colored_text(f"ğŸ” æ­£åœ¨ArXivæœç´¢: {translated_query}","yellow")

        papers = []
        page = 0
        per_page = 50  # ArXivæ¯é¡µæœ€å¤šæ˜¾ç¤º50ç¯‡è®ºæ–‡

        try:
            while len(papers) < max_results:
                # æ„å»ºæœç´¢URL
                params = {
                    'query': translated_query,
                    'searchtype': 'all',
                    'source': 'header',
                    'start': page * per_page
                }

                self.spws_ptr.append_colored_text(f"ğŸŒ æ­£åœ¨è·å–ç¬¬ {page + 1} é¡µ...","cyan")

                response = requests.get(self.base_url, params=params, headers=self.headers, timeout=30)
                response.raise_for_status()

                soup = BeautifulSoup(response.content, 'html.parser')

                # æŸ¥æ‰¾è®ºæ–‡æ¡ç›®
                paper_items = soup.find_all('li', class_='arxiv-result')

                if not paper_items:
                    self.spws_ptr.append_colored_text(f"âš ï¸  ç¬¬ {page + 1} é¡µæ²¡æœ‰æ‰¾åˆ°è®ºæ–‡ï¼Œåœæ­¢æœç´¢","yellow")
                    break

                self.spws_ptr.append_colored_text(f"âœ… ç¬¬ {page + 1} é¡µæ‰¾åˆ° {len(paper_items)} ç¯‡è®ºæ–‡","green")

                # è§£ææ¯ç¯‡è®ºæ–‡
                for item in paper_items:
                    if len(papers) >= max_results:
                        break

                    paper_info = self._parse_paper_item(item)
                    if paper_info:
                        papers.append(paper_info)

                # æ£€æŸ¥æ˜¯å¦è¿˜æœ‰æ›´å¤šé¡µé¢
                if len(paper_items) < per_page:
                    break

                page += 1
                time.sleep(1)  # é¿å…è¯·æ±‚è¿‡å¿«

        except requests.RequestException as e:
            self.spws_ptr.append_colored_text(f"âŒ ç½‘ç»œè¯·æ±‚å¤±è´¥: {e}","red")
        except Exception as e:
            self.spws_ptr.append_colored_text(f"âŒ è§£æå¤±è´¥: {e}","red")

        self.spws_ptr.append_colored_text(f"âœ… æ€»å…±æ‰¾åˆ° {len(papers)} ç¯‡ç›¸å…³è®ºæ–‡","green")
        return papers

    def _parse_paper_item(self, item) -> Dict:
        """è§£æå•ä¸ªè®ºæ–‡æ¡ç›®"""
        try:
            # è·å–æ ‡é¢˜
            title = item.find('p', class_="title is-5 mathjax").text
            if title:
                # print(title)
                pass
            else:
                title = "æœªçŸ¥æ ‡é¢˜"
                self.spws_ptr.textEdit.append("è·å–æ ‡é¢˜å¤±è´¥")

            # è·å–æ‘˜è¦é“¾æ¥
            abs_link = item.find('p', class_='list-title is-inline-block').find('a')['href']
            if abs_link:
                # print(abs_link)
                pass
            else:
                abs_link = "#"
                self.spws_ptr.textEdit.append("è·å–abs_linkå¤±è´¥")

            # è·å–ArXiv ID
            arxiv_id = item.find('p', class_='list-title is-inline-block').find('a').text.split(':')[1]
            if arxiv_id:
                # print(arxiv_id)
                pass
            else:
                arxiv_id = "æœªçŸ¥ID"
                self.spws_ptr.textEdit.append("è·å–arxiv_idå¤±è´¥")

            # æ„å»ºPDFé“¾æ¥
            pdf_link = f"https://arxiv.org/pdf/{arxiv_id}" if arxiv_id else "#"

            # è·å–ä½œè€…
            authors = []
            authors_elem = item.find('p', class_='authors')
            if authors_elem:
                author_links = authors_elem.find_all('a')
                for author_link in author_links:
                    authors.append(author_link.text.strip())

            # è·å–æ‘˜è¦
            abstract_elem = item.find('p', class_='abstract')
            if abstract_elem:
                abstract_text = abstract_elem.text.strip()
                if abstract_text.startswith('Abstract:'):
                    summary = abstract_text[9:].strip()
            else:
                summary = "æ— æ‘˜è¦"

            # è·å–å‘å¸ƒæ—¥æœŸ
            submitted_elem = item.find('p', class_='is-size-7')
            published_date = submitted_elem.text.strip() if submitted_elem else "æœªçŸ¥æ—¥æœŸ"

            # è·å–åˆ†ç±»ä¿¡æ¯
            categories = []
            subject_elem = item.find('div', class_='tags is-inline-block')
            if subject_elem:
                tag_links = subject_elem.find_all(class_='tag')
                for tag_link in tag_links:
                    category = tag_link.text.strip()
                    if category:
                        categories.append(category)

            # é™åˆ¶æ‘˜è¦é•¿åº¦
            if len(summary) > 500:
                summary = summary[:500] + '...'

            return {
                'title': title,
                'authors': authors,
                'summary': summary,
                'published_date': published_date,
                'arxiv_id': arxiv_id,
                'pdf_link': pdf_link,
                'abs_link': abs_link,
                'categories': categories,
                'authors_str': ', '.join(authors[:3]) + (' et al.' if len(authors) > 3 else '')
            }

        except Exception as e:
            self.spws_ptr.append_colored_text(f"âŒ è§£æè®ºæ–‡æ¡ç›®å¤±è´¥: {e}","red")
            return None

class PaperValueAssessmentAgent:
    """è®ºæ–‡ä»·å€¼è¯„ä¼°ä»£ç†"""

    def __init__(self,ptr):
        self.client = openai.OpenAI(api_key=my_api_key, base_url=my_base_url)
        self.model = my_model_name
        self.spws_ptr = ptr  # ç”¨äºä¸SPWSäº¤äº’

    def assess_papers(self, papers: List[Dict], theme: str, subject: str, outline: str) -> List[Dict]:
        """
        è¯„ä¼°è®ºæ–‡ä»·å€¼å¹¶æ’åº

        Args:
            papers: è®ºæ–‡åˆ—è¡¨
            theme: è®ºæ–‡ä¸»é¢˜æ–¹å‘
            subject: å…·ä½“ä¸»é¢˜
            outline: è®ºæ–‡æçº²

        Returns:
            æŒ‰ä»·å€¼æ’åºçš„è®ºæ–‡åˆ—è¡¨
        """
        self.spws_ptr.append_colored_text(f"ğŸ¯ æ­£åœ¨è¯„ä¼° {len(papers)} ç¯‡è®ºæ–‡çš„å‚è€ƒä»·å€¼...","yellow")

        # æ„å»ºè¯„ä¼°æç¤º
        assessment_prompt = self._build_assessment_prompt(papers, theme, subject, outline)

        try:
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system",
                    "content": "ä½ æ˜¯ä¸€åå­¦æœ¯è¯„ä¼°ä¸“å®¶ï¼Œéœ€è¦æ ¹æ®è®ºæ–‡ä¸ç»™å®šä¸»é¢˜çš„ç›¸å…³æ€§ã€å¼•ç”¨ä»·å€¼ã€ç ”ç©¶è´¨é‡ç­‰å› ç´ å¯¹è®ºæ–‡è¿›è¡Œè¯„åˆ†æ’åºã€‚"},
                    {"role": "user", "content": assessment_prompt}
                ],
                temperature=0.3,
                max_tokens=4096
            )

            assessment_result = response.choices[0].message.content
            ranked_papers = self._parse_assessment_result(assessment_result, papers)

            self.spws_ptr.append_colored_text(f"âœ… è®ºæ–‡ä»·å€¼è¯„ä¼°å®Œæˆï¼Œæ¨èå‰ {min(10, len(ranked_papers))} ç¯‡","green")
            return ranked_papers[:10]  # è¿”å›å‰10ç¯‡

        except Exception as e:
            self.spws_ptr.append_colored_text(f"âŒ è®ºæ–‡è¯„ä¼°å¤±è´¥: {e}","red")
            # å¦‚æœè¯„ä¼°å¤±è´¥ï¼ŒæŒ‰å‘å¸ƒæ—¶é—´æ’åºè¿”å›
            return sorted(papers, key=lambda x: x['published_date'], reverse=True)[:10]

    def _build_assessment_prompt(self, papers: List[Dict], theme: str, subject: str, outline: str) -> str:
        """æ„å»ºè¯„ä¼°æç¤º"""
        papers_info = ""
        for i, paper in enumerate(papers, 1):
            papers_info += f"""
è®ºæ–‡{i}:
- æ ‡é¢˜: {paper['title']}
- ä½œè€…: {paper['authors_str']}
- æ‘˜è¦: {paper['summary']}
- å‘å¸ƒæ—¶é—´: {paper['published_date']}
- åˆ†ç±»: {', '.join(paper['categories'][:3])}
---
"""

        prompt = f"""
è¯·è¯„ä¼°ä»¥ä¸‹è®ºæ–‡å¯¹äº"{theme}"é¢†åŸŸä¸­"{subject}"ä¸»é¢˜ç ”ç©¶çš„å‚è€ƒä»·å€¼ã€‚

ç ”ç©¶æçº²:
{outline}

å¾…è¯„ä¼°è®ºæ–‡:
{papers_info}

è¯„ä¼°æ ‡å‡†:
1. ä¸ç ”ç©¶ä¸»é¢˜çš„ç›¸å…³æ€§ (40%)
2. ç ”ç©¶æ–¹æ³•çš„åˆ›æ–°æ€§å’Œä¸¥è°¨æ€§ (25%)
3. å‘è¡¨æ—¶é—´çš„æ–°é¢–æ€§ (20%)
4. ä½œè€…æƒå¨æ€§å’ŒæœŸåˆŠè´¨é‡ (15%)

è¯·æŒ‰ä»¥ä¸‹JSONæ ¼å¼è¾“å‡ºè¯„ä¼°ç»“æœï¼ŒåŒ…å«æ¯ç¯‡è®ºæ–‡çš„è¯„åˆ†(1-10åˆ†)å’Œæ’åº:
```json
{{
  "rankings": [
    {{
      "paper_index": 1,
      "score": 8.5,
      "reasoning": "ç›¸å…³æ€§é«˜ï¼Œæ–¹æ³•åˆ›æ–°..."
    }},
    ...
  ]
}}
```

è¯·ç¡®ä¿JSONæ ¼å¼æ­£ç¡®ï¼ŒæŒ‰è¯„åˆ†ä»é«˜åˆ°ä½æ’åºã€‚
"""
        return prompt

    def _parse_assessment_result(self, assessment_result: str, papers: List[Dict]) -> List[Dict]:
        """è§£æè¯„ä¼°ç»“æœ"""
        try:
            # æå–JSONéƒ¨åˆ†
            json_match = re.search(r'```json\s*(\{.*?\})\s*```', assessment_result, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
                assessment_data = json.loads(json_str)

                # æŒ‰è¯„ä¼°ç»“æœæ’åºè®ºæ–‡
                ranked_papers = []
                for ranking in assessment_data.get('rankings', []):
                    paper_index = ranking.get('paper_index', 1) - 1  # è½¬æ¢ä¸º0åŸºç´¢å¼•
                    if 0 <= paper_index < len(papers):
                        paper = papers[paper_index].copy()
                        paper['assessment_score'] = ranking.get('score', 0)
                        paper['assessment_reasoning'] = ranking.get('reasoning', '')
                        ranked_papers.append(paper)

                return ranked_papers

        except (json.JSONDecodeError, KeyError) as e:
            self.spws_ptr.append_colored_text(f"âš ï¸  è¯„ä¼°ç»“æœè§£æå¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤æ’åº: {e}","yellow")

        # å¦‚æœè§£æå¤±è´¥ï¼ŒæŒ‰å‘å¸ƒæ—¶é—´æ’åº
        return sorted(papers, key=lambda x: x['published_date'], reverse=True)

class StreamingChatAgent:
    """å¸¦æµå¼å“åº”åŠŸèƒ½çš„èŠå¤©ä»£ç†"""

    def __init__(self, system_message="", output_language="zh",ptr=None):
        self.client = openai.OpenAI(api_key=my_api_key, base_url=my_base_url)
        self.model = my_model_name
        self.system_message = system_message
        self.output_language = output_language
        self.conversation_history = []
        self.spws_ptr = ptr  # ç”¨äºä¸SPWSäº¤äº’

        # æ·»åŠ ç³»ç»Ÿæ¶ˆæ¯åˆ°å¯¹è¯å†å²
        if system_message:
            self.conversation_history.append({"role": "system", "content": system_message})

    def stream_step(self, message: str, typing_delay: float = 0.001, show_role_prefix: str = ""):
        """æµå¼å“åº”å¤„ç†"""
        # æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°å†å²
        self.conversation_history.append({"role": "user", "content": message})

        try:
            # åˆ›å»ºæµå¼è¯·æ±‚
            stream = self.client.chat.completions.create(
                model=self.model,
                messages=self.conversation_history,
                temperature=0.8,
                max_tokens=8192,
                stream=True  # å¯ç”¨æµå¼è¾“å‡º
            )

            full_response = ""
            if show_role_prefix:
                self.spws_ptr.append_text(show_role_prefix, color="blue", newline=False)

            # é€å—å¤„ç†æµå¼å“åº”
            for chunk in stream:
                if chunk.choices[0].delta.content is not None:
                    content = chunk.choices[0].delta.content
                    full_response += content

                    cursor = self.spws_ptr.textEdit.textCursor()
                    cursor.movePosition(QtGui.QTextCursor.MoveOperation.End)
                    
                    for char in content:
                        # ä¸ºæ¯ä¸ªå­—ç¬¦åˆ›å»ºæ–°çš„æ ¼å¼å¹¶è®¾ç½®ä¸ºé»‘è‰²
                        char_format = QTextCharFormat()
                        char_format.setForeground(QColor("black"))
                        
                        # æ’å…¥å•ä¸ªå­—ç¬¦å¹¶åº”ç”¨æ ¼å¼
                        cursor.insertText(char, char_format)
                        
                        # ç¡®ä¿UIæ›´æ–°
                        QtCore.QCoreApplication.processEvents()
                        
                        # æ§åˆ¶è¾“å‡ºé€Ÿåº¦
                        time.sleep(typing_delay)
                    
                    # ç¡®ä¿å…‰æ ‡å¯è§
                    self.spws_ptr.textEdit.setTextCursor(cursor)
                    self.spws_ptr.textEdit.ensureCursorVisible()
                    # # æ‰“å­—æœºæ•ˆæœè¾“å‡º
                    # for char in content:
                    #     sys.stdout.write(char)
                    #     sys.stdout.flush()
                    #     time.sleep(typing_delay)

            self.spws_ptr.textEdit.append('\n')

            # ä¿å­˜å®Œæ•´å“åº”åˆ°å¯¹è¯å†å²
            self.conversation_history.append({"role": "assistant", "content": full_response})
            return full_response

        except Exception as e:
            self.spws_ptr.append_colored_text(f"âŒ æµå¼è¯·æ±‚å¤±è´¥: {e}","red")
            return f"è¯·æ±‚å¤±è´¥: {e}"


class StreamingPaperWritingSystem:
    """å¸¦æµå¼å“åº”çš„è®ºæ–‡å†™ä½œç³»ç»Ÿ"""

    def __init__(self,ptr):
        self.camel_model = ModelFactory.create(
            model_platform = ModelPlatformType.OPENAI,
            model_type=my_model_name,
            url=my_base_url,
            api_key=my_api_key,
            model_config_dict={
                "max_tokens": 4096
            }
        )
        self.spws_ptr = ptr  # ç”¨äºä¸SPWSäº¤äº’

        # åˆå§‹åŒ–å˜é‡
        self.theme = ""
        self.subject = ""
        self.outline = ""
        self.arxiv_crawler = ArxivCrawler(ptr=self.spws_ptr)
        self.value_assessor = PaperValueAssessmentAgent(ptr=self.spws_ptr)

    def generate_outline(self):

        # åˆ›å»ºæçº²ç”ŸæˆAgent
        outline_agent = StreamingChatAgent(
            system_message="ä½ æ˜¯ä¸€åå­¦æœ¯å†™ä½œä¸“å®¶ï¼Œéœ€ç”ŸæˆåŒ…å«ä»¥ä¸‹è¦ç´ çš„è®ºæ–‡æçº²ï¼š\n"
                           "1. ä¸¥æ ¼éµå¾ªIMRaDç»“æ„ï¼ˆå¼•è¨€ã€æ–¹æ³•ã€ç»“æœã€è®¨è®ºï¼‰\n"
                           "2. æ¯ä¸ªç« èŠ‚è‡³å°‘åŒ…å«2ä¸ªå­ç« èŠ‚\n"
                           "3. ç”¨Markdownæ ¼å¼è¾“å‡ºå±‚çº§æ ‡é¢˜",
            output_language="zh",
            ptr=self.spws_ptr
        )
        self.spws_ptr.append_colored_text("\nğŸ”„ æ­£åœ¨ç”Ÿæˆæçº²...","yellow")

        self.outline = outline_agent.stream_step(
            f"è¯·ç”Ÿæˆå…³äº{self.theme}çš„æœ‰å…³{self.subject}å†…å®¹çš„è®ºæ–‡æçº²",
            typing_delay=0.01,
            show_role_prefix=""
        )

    def start_collaborative_writing(self, rounds=3):
        """å¼€å§‹åä½œå†™ä½œè¿‡ç¨‹"""
        self.spws_ptr.append_colored_text(f"\nğŸ¯ å¼€å§‹å¸ˆç”Ÿåä½œä¼˜åŒ–ï¼ˆå…±{rounds}è½®ï¼‰","magenta")
        self.spws_ptr.textEdit.append("=" * 60)

        # åˆ›å»ºæµå¼ä»£ç†
        assistant_agent = StreamingChatAgent(
            system_message=f"""ä½ æ˜¯ä¸€åè¦æ±‚ä¸¥æ ¼çš„å¯¼å¸ˆ(RoleType:ASSISTANT)ï¼Œå¿…é¡»æŒ‰ä»¥ä¸‹è§„åˆ™æŒ‡å¯¼ï¼š
                            1. ç”¨'é€»è¾‘é—®é¢˜Xï¼š...'æ ¼å¼æŒ‡å‡ºæçº²ç¼ºé™·
                            2. æ¯æ¬¡åªæ1ä¸ªæ ¸å¿ƒé—®é¢˜
                            3. é¿å…ç›´æ¥ç»™å‡ºç­”æ¡ˆ
                            4. é‡ç‚¹å…³æ³¨{self.theme}é¢†åŸŸçš„{self.subject}ä¸“ä¸šé—®é¢˜""",
            output_language="zh",
            ptr=self.spws_ptr
        )

        user_agent = StreamingChatAgent(
            system_message=f"""ä½ æ˜¯å­¦ç”Ÿï¼ˆRoleType.USERï¼‰ï¼Œä½ æ­£åœ¨æ’°å†™å…³äº{self.theme}çš„æœ‰å…³{self.subject}å†…å®¹çš„è®ºæ–‡ï¼Œä½ çš„ä»»åŠ¡æ˜¯ï¼š
                            1. æ ¹æ®å¯¼å¸ˆçš„æ„è§å¯¹æçº²ä½œå‡ºä¿®æ”¹
                            2. æœ€ç»ˆç”Ÿæˆä¿®è®¢ç‰ˆæçº²""",
            output_language="zh",
            ptr=self.spws_ptr
        )

        # å­¦ç”Ÿå‘é€åˆå§‹æ¶ˆæ¯
        user_msg = f"ä»¥ä¸‹æ˜¯æˆ‘çš„è®ºæ–‡æçº²ï¼Œè¯·æ‰¹è¯„æŒ‡æ­£ï¼š\n\n{self.outline}"

        for i in range(rounds):
            # å¯¼å¸ˆæµå¼å›å¤
            self.spws_ptr.append_colored_text(f"\nğŸ‘¨â€ğŸ« å¯¼å¸ˆ ç¬¬{i + 1}è½®:","blue")
            assistant_msg = assistant_agent.stream_step(
                user_msg,
                typing_delay=0.001,
                show_role_prefix=""
            )

            # æœ€åä¸€è½®æŒ‡å¯¼åç›´æ¥ç”Ÿæˆæœ€ç»ˆæçº²
            if i + 1 == rounds:
                assistant_msg = assistant_msg + "æ³¨æ„ï¼è¿™ä¸€ç‰ˆä¿®æ”¹å®Œæ¯•åè¯·*ç›´æ¥*è¾“å‡ºå®Œæ•´çš„å¯ä»¥ç›´æ¥æ‹·è´çš„mdæ ¼å¼æçº²ï¼å¦åˆ™ä¸äºˆé€šè¿‡ï¼"

            # å­¦ç”Ÿæµå¼å›å¤
            self.spws_ptr.append_colored_text(f"\nğŸ§‘â€ğŸ“ å­¦ç”Ÿ ç¬¬{i + 1}è½®å›åº”:","green")
            user_msg = user_agent.stream_step(
                assistant_msg,
                typing_delay=0.001,
                show_role_prefix=""
            )

        self.spws_ptr.append_colored_text("\nğŸ‰ åä½œä¼˜åŒ–å®Œæˆï¼","cyan")
        return user_msg

    def save_final_outline(self, final_outline):
        """ä¿å­˜æœ€ç»ˆæçº²"""
        filename = f"{self.theme}_{self.subject}_è®ºæ–‡æçº².md"
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"# {self.theme} - {self.subject} è®ºæ–‡æçº²\n\n")
                f.write(f"**ç”Ÿæˆæ—¶é—´**: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                f.write("## æœ€ç»ˆä¼˜åŒ–æçº²\n\n")
                f.write(final_outline)

            self.spws_ptr.append_colored_text(f"\nğŸ’¾ æœ€ç»ˆæçº²å·²ä¿å­˜è‡³: {filename}","green")
        except Exception as e:
            self.spws_ptr.append_colored_text(f"\nâŒ ä¿å­˜å¤±è´¥: {e}","red")

    def search_and_save_references(self, final_outline):
        """ä½¿ç”¨ArXivçˆ¬è™«æœç´¢å¹¶è¯„ä¼°å‚è€ƒæ–‡çŒ®"""
        self.spws_ptr.append_colored_text("\nğŸ” æ­£åœ¨ä»ArXivæœç´¢ç›¸å…³è®ºæ–‡...","yellow")

        # æ„å»ºæœç´¢å…³é”®è¯
        search_query = f"{self.subject} {self.theme}"

        # çˆ¬å–è®ºæ–‡
        papers = self.arxiv_crawler.search_papers(search_query, max_results=50)

        if not papers:
            self.spws_ptr.append_colored_text("âŒ æœªæ‰¾åˆ°ç›¸å…³è®ºæ–‡","red")
            return

        # è¯„ä¼°è®ºæ–‡ä»·å€¼
        ranked_papers = self.value_assessor.assess_papers(papers, self.theme, self.subject, final_outline)

        # ä¿å­˜å‚è€ƒæ–‡çŒ®
        filename = f"{self.theme}_{self.subject}_å‚è€ƒæ–‡çŒ®.md"
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"# {self.theme} - {self.subject} å‚è€ƒæ–‡çŒ®\n\n")
                f.write(f"**ç”Ÿæˆæ—¶é—´**: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"**æœç´¢å…³é”®è¯**: {search_query}\n")
                f.write(f"**æ€»å…±æ‰¾åˆ°**: {len(papers)} ç¯‡è®ºæ–‡\n")
                f.write(f"**æ¨è**: å‰ {len(ranked_papers)} ç¯‡é«˜ä»·å€¼è®ºæ–‡\n\n")

                f.write("## æ¨èæ–‡çŒ®åˆ—è¡¨\n\n")

                for i, paper in enumerate(ranked_papers, 1):
                    f.write(f"### {i}. {paper['title']}\n\n")
                    f.write(f"**ä½œè€…**: {paper['authors_str']}\n\n")
                    f.write(f"**å‘å¸ƒæ—¶é—´**: {paper['published_date']}\n\n")
                    f.write(f"**ArXiv ID**: {paper['arxiv_id']}\n\n")
                    f.write(f"**åˆ†ç±»**: {', '.join(paper['categories'][:3])}\n\n")
                    f.write(f"**é“¾æ¥**: \n")
                    f.write(f"- [è®ºæ–‡æ‘˜è¦]({paper['abs_link']})\n")
                    f.write(f"- [PDFä¸‹è½½]({paper['pdf_link']})\n\n")
                    f.write(f"**æ‘˜è¦**: {paper['summary']}\n\n")

                    if 'assessment_score' in paper:
                        f.write(f"**è¯„ä¼°åˆ†æ•°**: {paper['assessment_score']}/10\n\n")
                    if 'assessment_reasoning' in paper:
                        f.write(f"**æ¨èç†ç”±**: {paper['assessment_reasoning']}\n\n")

                    f.write("---\n\n")

            self.spws_ptr.append_colored_text(f"\nğŸ’¾ å‚è€ƒæ–‡çŒ®å·²ä¿å­˜è‡³: {filename}","green")
            self.spws_ptr.append_colored_text(f"ğŸ“Š å…±æ¨è {len(ranked_papers)} ç¯‡é«˜è´¨é‡è®ºæ–‡","cyan")

        except Exception as e:
            self.spws_ptr.append_colored_text(f"\nâŒ ä¿å­˜å¤±è´¥: {e}","red")

    def run(self):
        try:
            # 1. ç”Ÿæˆæçº²
            self.generate_outline()
            # 2. å¼€å§‹åä½œä¼˜åŒ–
            final_outline = self.start_collaborative_writing(rounds=1)
            # 3. ä¿å­˜æœ€ç»ˆæçº²
            self.save_final_outline(final_outline)
            # 4. ä½¿ç”¨ArXivçˆ¬è™«æŸ¥æ‰¾å¹¶è¯„ä¼°å‚è€ƒæ–‡çŒ®
            self.search_and_save_references(final_outline)

        except KeyboardInterrupt:
            self.spws_ptr.append_colored_text("\n\nâš ï¸  ç”¨æˆ·ä¸­æ–­ç¨‹åº","yellow")
        except Exception as e:
            self.spws_ptr.append_colored_text(f"\nâŒ ç³»ç»Ÿé”™è¯¯: {e}","red")

class SPWS(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("å¸ˆç”Ÿåä½œå†™ä½œå¹³å°+é›†æˆçˆ¬è™«æ¨èæ–‡çŒ®åŠŸèƒ½")
        MainWindow.resize(800, 600)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayoutWidget = QtWidgets.QWidget(parent=self.centralwidget)
        self.horizontalLayoutWidget.setGeometry(QtCore.QRect(60, 10, 631, 80))
        self.horizontalLayoutWidget.setObjectName("horizontalLayoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(parent=self.horizontalLayoutWidget)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit_1 = QtWidgets.QLineEdit(parent=self.horizontalLayoutWidget)
        self.lineEdit_1.setObjectName("lineEdit_1")
        self.horizontalLayout.addWidget(self.lineEdit_1)
        self.horizontalLayoutWidget_2 = QtWidgets.QWidget(parent=self.centralwidget)
        self.horizontalLayoutWidget_2.setGeometry(QtCore.QRect(10, 100, 681, 80))
        self.horizontalLayoutWidget_2.setObjectName("horizontalLayoutWidget_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.horizontalLayoutWidget_2)
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_2 = QtWidgets.QLabel(parent=self.horizontalLayoutWidget_2)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.lineEdit_2 = QtWidgets.QLineEdit(parent=self.horizontalLayoutWidget_2)
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.horizontalLayout_2.addWidget(self.lineEdit_2)
        self.textEdit = QtWidgets.QTextEdit(parent=self.centralwidget)
        self.textEdit.setGeometry(QtCore.QRect(60, 210, 691, 321))
        self.textEdit.setObjectName("textEdit")
        self.pushButton = QtWidgets.QPushButton(parent=self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(710, 80, 75, 24))
        self.pushButton.setObjectName("pushButton")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton.clicked.connect(self.on_pushbutton_clicked)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "å¸ˆç”Ÿåä½œå†™ä½œå¹³å°+é›†æˆçˆ¬è™«æ¨èæ–‡çŒ®åŠŸèƒ½"))
        self.label.setText(_translate("MainWindow", "è®ºæ–‡ä¸»è¦æ–¹å‘ï¼ˆå¦‚ï¼šåŒ»å­¦ã€æ•°å­¦ã€è¯­æ–‡ç­‰ï¼‰ï¼š"))
        self.label_2.setText(_translate("MainWindow", "è®ºæ–‡ä¸»é¢˜ï¼ˆå¦‚ï¼šå¿ƒè¡€ç®¡ç–¾ç—…ã€å¾®ç§¯åˆ†ã€å¤ä»£è¯—è¯ç­‰ï¼‰ï¼š"))
        self.pushButton.setText(_translate("MainWindow", "ç”Ÿæˆ"))

    def on_pushbutton_clicked(self):
        theme = self.lineEdit_1.text()
        subject = self.lineEdit_2.text()
        if not theme or not subject:
            self.textEdit.setText("è¯·å¡«å†™è®ºæ–‡ä¸»è¦æ–¹å‘å’Œä¸»é¢˜ï¼")
            return

        # åˆ›å»ºè®ºæ–‡å†™ä½œç³»ç»Ÿå®ä¾‹
        spws = StreamingPaperWritingSystem(ptr=self)
        spws.theme = theme
        spws.subject = subject

        # è¿è¡Œè®ºæ–‡å†™ä½œæµç¨‹
        spws.run()

    # åœ¨ SPWS ç±»ä¸­æ·»åŠ ä¸€ä¸ªæ–¹æ³•æ¥å¤„ç†å¸¦é¢œè‰²çš„æ–‡æœ¬è¾“å‡º
    def append_colored_text(self, text, color_name="black"):
        """å‘ textEdit æ·»åŠ å¸¦é¢œè‰²çš„æ–‡æœ¬"""
        cursor = self.textEdit.textCursor()
        cursor.movePosition(QtGui.QTextCursor.MoveOperation.End)
        
        # è®¾ç½®æ–‡æœ¬æ ¼å¼
        fmt = QtGui.QTextCharFormat()
        if color_name == "red":
            fmt.setForeground(QtGui.QColor("#FF0000"))  # çº¢è‰²
        elif color_name == "green":
            fmt.setForeground(QtGui.QColor("#00FF00"))  # ç»¿è‰²
        elif color_name == "yellow":
            fmt.setForeground(QtGui.QColor("#FFD700"))  # é»„è‰²
        elif color_name == "blue":
            fmt.setForeground(QtGui.QColor("#0000FF"))  # è“è‰²
        elif color_name == "magenta":
            fmt.setForeground(QtGui.QColor("#FF00FF"))  # æ´‹çº¢
        elif color_name == "cyan":
            fmt.setForeground(QtGui.QColor("#00FFFF"))  # é’è‰²
        else:
            fmt.setForeground(QtGui.QColor("#000000"))  # é»˜è®¤é»‘è‰²
        
        # åº”ç”¨æ ¼å¼å¹¶æ’å…¥æ–‡æœ¬
        cursor.insertText(text + "\n", fmt)
        self.textEdit.setTextCursor(cursor)
        self.textEdit.ensureCursorVisible()  # è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
    
    def append_text(self, text, color="black", newline=True):
        """å‘ textEdit æ·»åŠ æ–‡æœ¬ï¼ˆå¯é€‰æ‹©é¢œè‰²å’Œæ˜¯å¦æ¢è¡Œï¼‰"""
        cursor = self.textEdit.textCursor()
        cursor.movePosition(QtGui.QTextCursor.MoveOperation.End)
        
        # è®¾ç½®æ–‡æœ¬æ ¼å¼
        fmt = QtGui.QTextCharFormat()
        if color == "red":
            fmt.setForeground(QtGui.QColor("#FF0000"))  # çº¢è‰²
        elif color == "green":
            fmt.setForeground(QtGui.QColor("#00FF00"))  # ç»¿è‰²
        elif color == "yellow":
            fmt.setForeground(QtGui.QColor("#FFD700"))  # é»„è‰²
        elif color == "blue":
            fmt.setForeground(QtGui.QColor("#0000FF"))  # è“è‰²
        elif color == "magenta":
            fmt.setForeground(QtGui.QColor("#FF00FF"))  # æ´‹çº¢
        elif color == "cyan":
            fmt.setForeground(QtGui.QColor("#00FFFF"))  # é’è‰²
        else:
            fmt.setForeground(QtGui.QColor("#000000"))  # é»˜è®¤é»‘è‰²
        
        # æ’å…¥æ–‡æœ¬
        cursor.insertText(text, fmt)
        if newline:
            cursor.insertText("\n")
        
        self.textEdit.setTextCursor(cursor)
        self.textEdit.ensureCursorVisible()

